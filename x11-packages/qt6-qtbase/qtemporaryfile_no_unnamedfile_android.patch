diff -uNr qtbase-everywhere-src-6.5.0/src/corelib/io/qtemporaryfile_p.h qtbase-everywhere-src-6.5.0.mod/src/corelib/io/qtemporaryfile_p.h
--- qtbase-everywhere-src-6.5.0/src/corelib/io/qtemporaryfile_p.h	2023-03-14 16:29:43.000000000 +0800
+++ qtbase-everywhere-src-6.5.0.mod/src/corelib/io/qtemporaryfile_p.h	2023-04-14 19:25:42.719998573 +0800
@@ -22,7 +22,7 @@
 #include "private/qfile_p.h"
 #include "qtemporaryfile.h"
 
-#if defined(Q_OS_LINUX) && QT_CONFIG(linkat)
+#if defined(Q_OS_LINUX) && !defined(__ANDROID__) && QT_CONFIG(linkat)
 #  include <fcntl.h>
 #  ifdef O_TMPFILE
 // some early libc support had the wrong values for O_TMPFILE
diff -uNr qtbase-everywhere-src-6.5.0/src/network/kernel/qdnslookup_unix.cpp.orig qtbase-everywhere-src-6.5.0.mod/src/network/kernel/qdnslookup_unix.cpp.orig
--- qtbase-everywhere-src-6.5.0/src/network/kernel/qdnslookup_unix.cpp.orig	1970-01-01 08:00:00.000000000 +0800
+++ qtbase-everywhere-src-6.5.0.mod/src/network/kernel/qdnslookup_unix.cpp.orig	2023-03-14 16:29:43.000000000 +0800
@@ -0,0 +1,387 @@
+// Copyright (C) 2012 Jeremy Lain√© <jeremy.laine@m4x.org>
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#include "qdnslookup_p.h"
+
+#if QT_CONFIG(library)
+#include <qlibrary.h>
+#endif
+#include <qvarlengtharray.h>
+#include <qscopedpointer.h>
+#include <qurl.h>
+#include <private/qnativesocketengine_p.h>
+
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <arpa/nameser.h>
+#if !defined(Q_OS_OPENBSD)
+#  include <arpa/nameser_compat.h>
+#endif
+#include <resolv.h>
+
+#if defined(__GNU_LIBRARY__) && !defined(__UCLIBC__)
+#  include <gnu/lib-names.h>
+#endif
+
+#if defined(Q_OS_FREEBSD) || QT_CONFIG(dlopen)
+#  include <dlfcn.h>
+#endif
+
+#include <cstring>
+
+QT_BEGIN_NAMESPACE
+
+using namespace Qt::StringLiterals;
+
+#if QT_CONFIG(library)
+
+#if defined(Q_OS_OPENBSD)
+typedef struct __res_state* res_state;
+#endif
+typedef int (*dn_expand_proto)(const unsigned char *, const unsigned char *, const unsigned char *, char *, int);
+static dn_expand_proto local_dn_expand = nullptr;
+typedef void (*res_nclose_proto)(res_state);
+static res_nclose_proto local_res_nclose = nullptr;
+typedef int (*res_ninit_proto)(res_state);
+static res_ninit_proto local_res_ninit = nullptr;
+typedef int (*res_nquery_proto)(res_state, const char *, int, int, unsigned char *, int);
+static res_nquery_proto local_res_nquery = nullptr;
+
+// Custom deleter to close resolver state.
+
+struct QDnsLookupStateDeleter
+{
+    static inline void cleanup(struct __res_state *pointer)
+    {
+        local_res_nclose(pointer);
+    }
+};
+
+static QFunctionPointer resolveSymbol(QLibrary &lib, const char *sym)
+{
+    if (lib.isLoaded())
+        return lib.resolve(sym);
+
+#if defined(RTLD_DEFAULT) && (defined(Q_OS_FREEBSD) || QT_CONFIG(dlopen))
+    return reinterpret_cast<QFunctionPointer>(dlsym(RTLD_DEFAULT, sym));
+#else
+    return nullptr;
+#endif
+}
+
+static bool resolveLibraryInternal()
+{
+    QLibrary lib;
+#ifdef LIBRESOLV_SO
+    lib.setFileName(QStringLiteral(LIBRESOLV_SO));
+    if (!lib.load())
+#endif
+    {
+        lib.setFileName("resolv"_L1);
+        lib.load();
+    }
+
+    local_dn_expand = dn_expand_proto(resolveSymbol(lib, "__dn_expand"));
+    if (!local_dn_expand)
+        local_dn_expand = dn_expand_proto(resolveSymbol(lib, "dn_expand"));
+
+    local_res_nclose = res_nclose_proto(resolveSymbol(lib, "__res_nclose"));
+    if (!local_res_nclose)
+        local_res_nclose = res_nclose_proto(resolveSymbol(lib, "res_9_nclose"));
+    if (!local_res_nclose)
+        local_res_nclose = res_nclose_proto(resolveSymbol(lib, "res_nclose"));
+
+    local_res_ninit = res_ninit_proto(resolveSymbol(lib, "__res_ninit"));
+    if (!local_res_ninit)
+        local_res_ninit = res_ninit_proto(resolveSymbol(lib, "res_9_ninit"));
+    if (!local_res_ninit)
+        local_res_ninit = res_ninit_proto(resolveSymbol(lib, "res_ninit"));
+
+    local_res_nquery = res_nquery_proto(resolveSymbol(lib, "__res_nquery"));
+    if (!local_res_nquery)
+        local_res_nquery = res_nquery_proto(resolveSymbol(lib, "res_9_nquery"));
+    if (!local_res_nquery)
+        local_res_nquery = res_nquery_proto(resolveSymbol(lib, "res_nquery"));
+
+    return true;
+}
+Q_GLOBAL_STATIC_WITH_ARGS(bool, resolveLibrary, (resolveLibraryInternal()))
+
+void QDnsLookupRunnable::query(const int requestType, const QByteArray &requestName, const QHostAddress &nameserver, QDnsLookupReply *reply)
+{
+    // Load dn_expand, res_ninit and res_nquery on demand.
+    resolveLibrary();
+
+    // If dn_expand, res_ninit or res_nquery is missing, fail.
+    if (!local_dn_expand || !local_res_nclose || !local_res_ninit || !local_res_nquery) {
+        reply->error = QDnsLookup::ResolverError;
+        reply->errorString = tr("Resolver functions not found");
+        return;
+    }
+
+    // Initialize state.
+    struct __res_state state;
+    std::memset(&state, 0, sizeof(state));
+    if (local_res_ninit(&state) < 0) {
+        reply->error = QDnsLookup::ResolverError;
+        reply->errorString = tr("Resolver initialization failed");
+        return;
+    }
+
+    //Check if a nameserver was set. If so, use it
+    if (!nameserver.isNull()) {
+        if (nameserver.protocol() == QAbstractSocket::IPv4Protocol) {
+            state.nsaddr_list[0].sin_addr.s_addr = htonl(nameserver.toIPv4Address());
+            state.nscount = 1;
+        } else if (nameserver.protocol() == QAbstractSocket::IPv6Protocol) {
+#if defined(Q_OS_LINUX)
+            struct sockaddr_in6 *ns;
+            ns = state._u._ext.nsaddrs[0];
+            // nsaddrs will be NULL if no nameserver is set in /etc/resolv.conf
+            if (!ns) {
+                // Memory allocated here will be free'd in res_close() as we
+                // have done res_init() above.
+                ns = (struct sockaddr_in6*) calloc(1, sizeof(struct sockaddr_in6));
+                Q_CHECK_PTR(ns);
+                state._u._ext.nsaddrs[0] = ns;
+            }
+#ifndef __UCLIBC__
+            // Set nsmap[] to indicate that nsaddrs[0] is an IPv6 address
+            // See: https://sourceware.org/ml/libc-hacker/2002-05/msg00035.html
+            state._u._ext.nsmap[0] = MAXNS + 1;
+#endif
+            state._u._ext.nscount6 = 1;
+            ns->sin6_family = AF_INET6;
+            ns->sin6_port = htons(53);
+            SetSALen::set(ns, sizeof(*ns));
+
+            Q_IPV6ADDR ipv6Address = nameserver.toIPv6Address();
+            for (int i=0; i<16; i++) {
+                ns->sin6_addr.s6_addr[i] = ipv6Address[i];
+            }
+#else
+            qWarning("%s", QDnsLookupPrivate::msgNoIpV6NameServerAdresses);
+            reply->error = QDnsLookup::ResolverError;
+            reply->errorString = tr(QDnsLookupPrivate::msgNoIpV6NameServerAdresses);
+            return;
+#endif
+        }
+    }
+#ifdef QDNSLOOKUP_DEBUG
+    state.options |= RES_DEBUG;
+#endif
+    QScopedPointer<struct __res_state, QDnsLookupStateDeleter> state_ptr(&state);
+
+    // Perform DNS query.
+    QVarLengthArray<unsigned char, PACKETSZ> buffer(PACKETSZ);
+    std::memset(buffer.data(), 0, buffer.size());
+    int responseLength = local_res_nquery(&state, requestName, C_IN, requestType, buffer.data(), buffer.size());
+    if (Q_UNLIKELY(responseLength > PACKETSZ)) {
+        buffer.resize(responseLength);
+        std::memset(buffer.data(), 0, buffer.size());
+        responseLength = local_res_nquery(&state, requestName, C_IN, requestType, buffer.data(), buffer.size());
+        if (Q_UNLIKELY(responseLength > buffer.size())) {
+            // Ok, we give up.
+            reply->error = QDnsLookup::ResolverError;
+            reply->errorString.clear(); // We cannot be more specific, alas.
+            return;
+        }
+    }
+
+    unsigned char *response = buffer.data();
+    // Check the response header. Though res_nquery returns -1 as a
+    // responseLength in case of error, we still can extract the
+    // exact error code from the response.
+    HEADER *header = (HEADER*)response;
+    const int answerCount = ntohs(header->ancount);
+    switch (header->rcode) {
+    case NOERROR:
+        break;
+    case FORMERR:
+        reply->error = QDnsLookup::InvalidRequestError;
+        reply->errorString = tr("Server could not process query");
+        return;
+    case SERVFAIL:
+        reply->error = QDnsLookup::ServerFailureError;
+        reply->errorString = tr("Server failure");
+        return;
+    case NXDOMAIN:
+        reply->error = QDnsLookup::NotFoundError;
+        reply->errorString = tr("Non existent domain");
+        return;
+    case REFUSED:
+        reply->error = QDnsLookup::ServerRefusedError;
+        reply->errorString = tr("Server refused to answer");
+        return;
+    default:
+        reply->error = QDnsLookup::InvalidReplyError;
+        reply->errorString = tr("Invalid reply received");
+        return;
+    }
+
+    // Check the reply is valid.
+    if (responseLength < int(sizeof(HEADER))) {
+        reply->error = QDnsLookup::InvalidReplyError;
+        reply->errorString = tr("Invalid reply received");
+        return;
+    }
+
+    // Skip the query host, type (2 bytes) and class (2 bytes).
+    char host[PACKETSZ], answer[PACKETSZ];
+    unsigned char *p = response + sizeof(HEADER);
+    int status = local_dn_expand(response, response + responseLength, p, host, sizeof(host));
+    if (status < 0) {
+        reply->error = QDnsLookup::InvalidReplyError;
+        reply->errorString = tr("Could not expand domain name");
+        return;
+    }
+    p += status + 4;
+
+    // Extract results.
+    int answerIndex = 0;
+    while ((p < response + responseLength) && (answerIndex < answerCount)) {
+        status = local_dn_expand(response, response + responseLength, p, host, sizeof(host));
+        if (status < 0) {
+            reply->error = QDnsLookup::InvalidReplyError;
+            reply->errorString = tr("Could not expand domain name");
+            return;
+        }
+        const QString name = QUrl::fromAce(host);
+
+        p += status;
+        const quint16 type = (p[0] << 8) | p[1];
+        p += 2; // RR type
+        p += 2; // RR class
+        const quint32 ttl = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
+        p += 4;
+        const quint16 size = (p[0] << 8) | p[1];
+        p += 2;
+
+        if (type == QDnsLookup::A) {
+            if (size != 4) {
+                reply->error = QDnsLookup::InvalidReplyError;
+                reply->errorString = tr("Invalid IPv4 address record");
+                return;
+            }
+            const quint32 addr = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
+            QDnsHostAddressRecord record;
+            record.d->name = name;
+            record.d->timeToLive = ttl;
+            record.d->value = QHostAddress(addr);
+            reply->hostAddressRecords.append(record);
+        } else if (type == QDnsLookup::AAAA) {
+            if (size != 16) {
+                reply->error = QDnsLookup::InvalidReplyError;
+                reply->errorString = tr("Invalid IPv6 address record");
+                return;
+            }
+            QDnsHostAddressRecord record;
+            record.d->name = name;
+            record.d->timeToLive = ttl;
+            record.d->value = QHostAddress(p);
+            reply->hostAddressRecords.append(record);
+        } else if (type == QDnsLookup::CNAME) {
+            status = local_dn_expand(response, response + responseLength, p, answer, sizeof(answer));
+            if (status < 0) {
+                reply->error = QDnsLookup::InvalidReplyError;
+                reply->errorString = tr("Invalid canonical name record");
+                return;
+            }
+            QDnsDomainNameRecord record;
+            record.d->name = name;
+            record.d->timeToLive = ttl;
+            record.d->value = QUrl::fromAce(answer);
+            reply->canonicalNameRecords.append(record);
+        } else if (type == QDnsLookup::NS) {
+            status = local_dn_expand(response, response + responseLength, p, answer, sizeof(answer));
+            if (status < 0) {
+                reply->error = QDnsLookup::InvalidReplyError;
+                reply->errorString = tr("Invalid name server record");
+                return;
+            }
+            QDnsDomainNameRecord record;
+            record.d->name = name;
+            record.d->timeToLive = ttl;
+            record.d->value = QUrl::fromAce(answer);
+            reply->nameServerRecords.append(record);
+        } else if (type == QDnsLookup::PTR) {
+            status = local_dn_expand(response, response + responseLength, p, answer, sizeof(answer));
+            if (status < 0) {
+                reply->error = QDnsLookup::InvalidReplyError;
+                reply->errorString = tr("Invalid pointer record");
+                return;
+            }
+            QDnsDomainNameRecord record;
+            record.d->name = name;
+            record.d->timeToLive = ttl;
+            record.d->value = QUrl::fromAce(answer);
+            reply->pointerRecords.append(record);
+        } else if (type == QDnsLookup::MX) {
+            const quint16 preference = (p[0] << 8) | p[1];
+            status = local_dn_expand(response, response + responseLength, p + 2, answer, sizeof(answer));
+            if (status < 0) {
+                reply->error = QDnsLookup::InvalidReplyError;
+                reply->errorString = tr("Invalid mail exchange record");
+                return;
+            }
+            QDnsMailExchangeRecord record;
+            record.d->exchange = QUrl::fromAce(answer);
+            record.d->name = name;
+            record.d->preference = preference;
+            record.d->timeToLive = ttl;
+            reply->mailExchangeRecords.append(record);
+        } else if (type == QDnsLookup::SRV) {
+            const quint16 priority = (p[0] << 8) | p[1];
+            const quint16 weight = (p[2] << 8) | p[3];
+            const quint16 port = (p[4] << 8) | p[5];
+            status = local_dn_expand(response, response + responseLength, p + 6, answer, sizeof(answer));
+            if (status < 0) {
+                reply->error = QDnsLookup::InvalidReplyError;
+                reply->errorString = tr("Invalid service record");
+                return;
+            }
+            QDnsServiceRecord record;
+            record.d->name = name;
+            record.d->target = QUrl::fromAce(answer);
+            record.d->port = port;
+            record.d->priority = priority;
+            record.d->timeToLive = ttl;
+            record.d->weight = weight;
+            reply->serviceRecords.append(record);
+        } else if (type == QDnsLookup::TXT) {
+            unsigned char *txt = p;
+            QDnsTextRecord record;
+            record.d->name = name;
+            record.d->timeToLive = ttl;
+            while (txt < p + size) {
+                const unsigned char length = *txt;
+                txt++;
+                if (txt + length > p + size) {
+                    reply->error = QDnsLookup::InvalidReplyError;
+                    reply->errorString = tr("Invalid text record");
+                    return;
+                }
+                record.d->values << QByteArray((char*)txt, length);
+                txt += length;
+            }
+            reply->textRecords.append(record);
+        }
+        p += size;
+        answerIndex++;
+    }
+}
+
+#else
+void QDnsLookupRunnable::query(const int requestType, const QByteArray &requestName, const QHostAddress &nameserver, QDnsLookupReply *reply)
+{
+    Q_UNUSED(requestType);
+    Q_UNUSED(requestName);
+    Q_UNUSED(nameserver);
+    reply->error = QDnsLookup::ResolverError;
+    reply->errorString = tr("Resolver library can't be loaded: No runtime library loading support");
+    return;
+}
+
+#endif /* QT_CONFIG(library) */
+
+QT_END_NAMESPACE
diff -uNr qtbase-everywhere-src-6.5.0/src/network/kernel/qhostinfo_unix.cpp.orig qtbase-everywhere-src-6.5.0.mod/src/network/kernel/qhostinfo_unix.cpp.orig
--- qtbase-everywhere-src-6.5.0/src/network/kernel/qhostinfo_unix.cpp.orig	1970-01-01 08:00:00.000000000 +0800
+++ qtbase-everywhere-src-6.5.0.mod/src/network/kernel/qhostinfo_unix.cpp.orig	2023-03-14 16:29:43.000000000 +0800
@@ -0,0 +1,222 @@
+// Copyright (C) 2016 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+//#define QHOSTINFO_DEBUG
+
+#include "qplatformdefs.h"
+
+#include "qhostinfo_p.h"
+#include "private/qnativesocketengine_p.h"
+#include "qiodevice.h"
+#include <qbytearray.h>
+#if QT_CONFIG(library)
+#include <qlibrary.h>
+#endif
+#include <qbasicatomic.h>
+#include <qurl.h>
+#include <qfile.h>
+#include <private/qnet_unix_p.h>
+
+#include "QtCore/qapplicationstatic.h"
+
+#include <sys/types.h>
+#include <netdb.h>
+#include <arpa/inet.h>
+#if defined(Q_OS_VXWORKS)
+#  include <hostLib.h>
+#else
+#  include <resolv.h>
+#endif
+
+#if defined(__GNU_LIBRARY__) && !defined(__UCLIBC__)
+#  include <gnu/lib-names.h>
+#endif
+
+#if defined(Q_OS_FREEBSD) || QT_CONFIG(dlopen)
+#  include <dlfcn.h>
+#endif
+
+QT_BEGIN_NAMESPACE
+
+using namespace Qt::StringLiterals;
+
+enum LibResolvFeature {
+    NeedResInit,
+    NeedResNInit
+};
+
+typedef struct __res_state *res_state_ptr;
+
+typedef int (*res_init_proto)(void);
+static res_init_proto local_res_init = nullptr;
+typedef int (*res_ninit_proto)(res_state_ptr);
+static res_ninit_proto local_res_ninit = nullptr;
+typedef void (*res_nclose_proto)(res_state_ptr);
+static res_nclose_proto local_res_nclose = nullptr;
+static res_state_ptr local_res = nullptr;
+
+#if QT_CONFIG(library) && !defined(Q_OS_QNX)
+namespace {
+struct LibResolv
+{
+    enum {
+#ifdef RES_NORELOAD
+        // If RES_NORELOAD is defined, then the libc is capable of watching
+        // /etc/resolv.conf for changes and reloading as necessary. So accept
+        // whatever is configured.
+        ReinitNecessary = false
+#else
+        ReinitNecessary = true
+#endif
+    };
+
+    QLibrary lib;
+    LibResolv();
+    ~LibResolv() { lib.unload(); }
+};
+}
+
+static QFunctionPointer resolveSymbol(QLibrary &lib, const char *sym)
+{
+    if (lib.isLoaded())
+        return lib.resolve(sym);
+
+#if defined(RTLD_DEFAULT) && (defined(Q_OS_FREEBSD) || QT_CONFIG(dlopen))
+    return reinterpret_cast<QFunctionPointer>(dlsym(RTLD_DEFAULT, sym));
+#else
+    return nullptr;
+#endif
+}
+
+LibResolv::LibResolv()
+{
+#ifdef LIBRESOLV_SO
+    lib.setFileName(QStringLiteral(LIBRESOLV_SO));
+    if (!lib.load())
+#endif
+    {
+        lib.setFileName("resolv"_L1);
+        lib.load();
+    }
+
+    // res_ninit is required for localDomainName()
+    local_res_ninit = res_ninit_proto(resolveSymbol(lib, "__res_ninit"));
+    if (!local_res_ninit)
+        local_res_ninit = res_ninit_proto(resolveSymbol(lib, "res_ninit"));
+    if (local_res_ninit) {
+        // we must now find res_nclose
+        local_res_nclose = res_nclose_proto(resolveSymbol(lib, "res_nclose"));
+        if (!local_res_nclose)
+            local_res_nclose = res_nclose_proto(resolveSymbol(lib, "__res_nclose"));
+        if (!local_res_nclose)
+            local_res_ninit = nullptr;
+    }
+
+    if (ReinitNecessary || !local_res_ninit) {
+        local_res_init = res_init_proto(resolveSymbol(lib, "__res_init"));
+        if (!local_res_init)
+            local_res_init = res_init_proto(resolveSymbol(lib, "res_init"));
+
+        if (local_res_init && !local_res_ninit) {
+            // if we can't get a thread-safe context, we have to use the global _res state
+            local_res = res_state_ptr(resolveSymbol(lib, "_res"));
+        }
+    }
+}
+
+Q_APPLICATION_STATIC(LibResolv, libResolv)
+
+static void resolveLibrary(LibResolvFeature f)
+{
+    if (LibResolv::ReinitNecessary || f == NeedResNInit)
+        libResolv();
+}
+#else // QT_CONFIG(library) || Q_OS_QNX
+static void resolveLibrary(LibResolvFeature)
+{
+}
+#endif // QT_CONFIG(library) || Q_OS_QNX
+
+QHostInfo QHostInfoAgent::fromName(const QString &hostName)
+{
+    QHostInfo results;
+
+#if defined(QHOSTINFO_DEBUG)
+    qDebug("QHostInfoAgent::fromName(%s) looking up...",
+           hostName.toLatin1().constData());
+#endif
+
+    // Load res_init on demand.
+    resolveLibrary(NeedResInit);
+
+    // If res_init is available, poll it.
+    if (local_res_init)
+        local_res_init();
+
+    QHostAddress address;
+    if (address.setAddress(hostName))
+        return reverseLookup(address);
+
+    return lookup(hostName);
+}
+
+QString QHostInfo::localDomainName()
+{
+#if !defined(Q_OS_VXWORKS) && !defined(Q_OS_ANDROID)
+    resolveLibrary(NeedResNInit);
+    if (local_res_ninit) {
+        // using thread-safe version
+        res_state_ptr state = res_state_ptr(malloc(sizeof(*state)));
+        Q_CHECK_PTR(state);
+        memset(state, 0, sizeof(*state));
+        local_res_ninit(state);
+        QString domainName = QUrl::fromAce(state->defdname);
+        if (domainName.isEmpty())
+            domainName = QUrl::fromAce(state->dnsrch[0]);
+        local_res_nclose(state);
+        free(state);
+
+        return domainName;
+    }
+
+    if (local_res_init && local_res) {
+        // using thread-unsafe version
+
+        local_res_init();
+        QString domainName = QUrl::fromAce(local_res->defdname);
+        if (domainName.isEmpty())
+            domainName = QUrl::fromAce(local_res->dnsrch[0]);
+        return domainName;
+    }
+#endif
+    // nothing worked, try doing it by ourselves:
+    QFile resolvconf;
+#if defined(_PATH_RESCONF)
+    resolvconf.setFileName(QFile::decodeName(_PATH_RESCONF));
+#else
+    resolvconf.setFileName("/etc/resolv.conf"_L1);
+#endif
+    if (!resolvconf.open(QIODevice::ReadOnly))
+        return QString();       // failure
+
+    QString domainName;
+    while (!resolvconf.atEnd()) {
+        QByteArray line = resolvconf.readLine().trimmed();
+        if (line.startsWith("domain "))
+            return QUrl::fromAce(line.mid(sizeof "domain " - 1).trimmed());
+
+        // in case there's no "domain" line, fall back to the first "search" entry
+        if (domainName.isEmpty() && line.startsWith("search ")) {
+            QByteArray searchDomain = line.mid(sizeof "search " - 1).trimmed();
+            int pos = searchDomain.indexOf(' ');
+            if (pos != -1)
+                searchDomain.truncate(pos);
+            domainName = QUrl::fromAce(searchDomain);
+        }
+    }
+
+    // return the fallen-back-to searched domain
+    return domainName;
+}
+
+QT_END_NAMESPACE
